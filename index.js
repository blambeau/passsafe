CryptoJS = require('crypto-js/core');
pbkdf2   = require("crypto-js/pbkdf2");

Passsafe = module.exports = {};

Passsafe.DEFAULT_OPTIONS = {};

// Size of the salt to use
Passsafe.DEFAULT_OPTIONS.SALT_SIZE = 128/8;

// Size of the key to use
Passsafe.DEFAULT_OPTIONS.KEY_SIZE = 128/32;

// Number of iterations to use
Passsafe.DEFAULT_OPTIONS.ITERATIONS = 1000;

// ----------------------------------------------------------------------- Facade

/*
 * Hashes a password in clear plain text.
 *
 * @arg clearPassword password in clear text.
 * @return the password hashed as a string.
 * @api public
 */
Passsafe.hash = function(clearPassword, options){
	return Passsafe.clear(clearPassword, options).toHashed();
};

/*
 * Checks if a clear text password is valid against a previously hashed one.
 *
 * @arg clearPassword a password in clear text, to be checked.
 * @arg hashed the result of a previous call to `hash` with a password.
 * @return true if the password is valid, false otherwise.
 */
Passsafe.isValid = function(clearPassword, hashed, options){
	return Passsafe.hashed(hashed, options).isValid(clearPassword);
};

// ----------------------------------------------------------------------- Clear

/*
 * Creates and returns a password instance from a clear password text.
 *
 * @arg clearPassword: the password in plain clear text
 * @arg options: options to use (optional, defaults to Passafe.DEFAULT_OPTIONS)
 * @arg salt: salt to use (optional, defaults to autogenerated)
 * @return a password instance, that you can hash if needed.
 * @api public
 */
Passsafe.clear = function(clearPassword, options, salt) {
	return new Passsafe.Clear(clearPassword, options, salt);
};

/*
 * Creates a clear password instance.
 *
 * @arg clearPassword: the password in plain clear text
 * @arg options: options to use (optional)
 * @arg salt: some random salt (optional)
 * @return an instance of the Password.Clear class
 * @api private
 */
Passsafe.Clear = function(clearPassword, options, salt) {
	this.clearPassword = clearPassword;
	this.options = options || Passsafe.DEFAULT_OPTIONS;
	this.salt = salt || CryptoJS.lib.WordArray.random(this.options.SALT_SIZE);
};

/*
 * Returns a clear text version of the password.
 *
 * @api public
 * @return String an clear string version of the password
 */
Passsafe.Clear.prototype.toClear = function(){
	return this.clearPassword;
};

/*
 * Returns an hashed text version of the password.
 *
 * @api public
 * @return String an hashed string version of the password
 */
Passsafe.Clear.prototype.toHashed = function(){
	return this.hash().toHashed();
};

/*
 * Returns an unhashed version of this password.
 *
 * @api public
 * @return this.
 */
Passsafe.Clear.prototype.unhash = function(){
	return this;
};

/*
 * Returns an hashed version of this password.
 *
 * @api public
 * @return Passafe.Hashed an hashed instance.
 */
Passsafe.Clear.prototype.hash = function(){
	var hashed = this.salt.toString(CryptoJS.enc.Hex) + CryptoJS.PBKDF2(this.clearPassword, this.salt, {
		keySize: this.options.KEY_SIZE,
		iterations: this.options.ITERATIONS
	});
	return Passsafe.hashed(hashed, this.options, this.salt);
};

/*
 * Check if the clear text password passed as argument is the same
 * password as this.
 *
 * @api public
 * @return true if same password, false otherwise.
 */
Passsafe.Clear.prototype.isValid = function(clearPassword){
	return this.clearPassword == clearPassword;
};

/*
 * Check if this password is the same as `other`.
 *
 * @arg other a Passsafe instance
 * @return true if the same password, false otherwise.
 */
Passsafe.Clear.prototype.equals = function(other){
	return this.toHashed() == other.toHashed();
};

// ----------------------------------------------------------------------- Clear

/*
 * Creates and returns a password instance from an hashed password text.
 *
 * @arg hashedPassword: the password in plain hashed text
 * @return an hashed password instance.
 * @api public
 */
Passsafe.hashed = function(hashedPassword, options, salt) {
	return new Passsafe.Hashed(hashedPassword, options, salt);
};

/*
 * Creates an hashed password instance.
 *
 * @arg hashedPassword the password in hashed plain text.
 * @return an instance of the Password.Hashed class
 * @api private
 */
Passsafe.Hashed = function(hashedPassword, options, salt) {
	this.hashedPassword = hashedPassword;
	this.options = options || Passsafe.DEFAULT_OPTIONS;
	this.salt = salt || CryptoJS.enc.Hex.parse(hashedPassword.slice(0, this.options.SALT_SIZE*2));
};

/*
 * Check if the clear text password passed as argument is the same
 * password as this.
 *
 * @api public
 * @return true if same password, false otherwise.
 */
Passsafe.Hashed.prototype.isValid = function(clearPassword){
	return (Passsafe.clear(clearPassword, this.options, this.salt).toHashed() == this.hashedPassword);
};

/*
 * Throws an error, as password hasing is one-way.
 *
 * @api public
 */
Passsafe.Hashed.prototype.toClear = function(){
	throw "not supported: password hashing works one-way";
};

/*
 * Returns this password as a string.
 *
 * @return String the hashed password as a plain text string.
 */
Passsafe.Hashed.prototype.toHashed = function(){
	return this.hashedPassword;
};

/*
 * Throws an error, as password hasing is one-way.
 *
 * @api public
 * @return this.
 */
Passsafe.Hashed.prototype.unhash = function(){
	throw "not supported: password hashing works one-way";
};

/*
 * Returns an hashed version of this password.
 *
 * @api public
 * @return this.
 */
Passsafe.Hashed.prototype.hash = function(){
	return this;
};

/*
 * Check if this password is the same as `other`.
 *
 * @arg other a Passsafe instance
 * @return true if the same password, false otherwise.
 */
Passsafe.Hashed.prototype.equals = function(other){
	return this.toHashed() == other.toHashed();
};
